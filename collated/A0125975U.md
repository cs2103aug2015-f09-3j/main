# A0125975U
###### src\application\controller\DataManager.java
``` java
	public void switchToTestingMode(String filePath) {
		data = new Data(filePath);
		paraList = null;
	}

	/**
	 * This function return a list of suitable task for its first sync.
	 * 
	 * @return
	 */
	public ArrayList<Task> getListOfUnSyncNonFloatingTasks() {

		ArrayList<Task> unSyncTasks = new ArrayList<Task>();

		for (Task task : data.getTaskList()) {
			if (task.isUnSyncedTask() && task.isNonFloatingTask()) {
				unSyncTasks.add(task);
			}
		}

		return unSyncTasks;

	}

	/**
	 * This function will return a list of modified gCal Sync-ed task.
	 * 
	 * @return a list of Tasks that have been modified locally since last server
	 *         update.
	 */
	public ArrayList<Task> getListOfModifiedTask() {

		ArrayList<Task> filteredList = new ArrayList<Task>();

		for (Task task : data.getTaskList()) {
			if (task.isModified()) {
				filteredList.add(task);
			}
		}

		return filteredList;
	}

	/**
	 * This function finds local task by its GCalId.
	 * 
	 * @param gCalId
	 * @return return tasks with that GCalId, If Any. Otherwise, return null.
	 */
	public Task findTaskByGCalId(String gCalId) {

		for (Task task : data.getTaskList()) {
			if (task.compareGCalId(gCalId)) {
				return task;
			}
		}
		return null;
	}

	/**
	 * This function deletes task by its GCalId, If Any.
	 * 
	 * @param gCalId
	 */
	public void deleteTaskByGCalId(String gCalId) {
		Task task = findTaskByGCalId(gCalId);
		if (task == null) {
			return;
		}
		int indexToDelete = data.getTaskList().indexOf(task);
		data.getTaskList().remove(indexToDelete);

		data.updateStorage();

	}

	/**
	 * This function takes in HashMap of Task and String, It takes the
	 * value(GCalId) and update its key(Task).
	 * 
	 * @param lists
	 *            : HashMap of key(Task) and value(String)(GCalId) pair.
	 * 
	 */
	public void updateGCalId(HashMap<Task, String> lists) {

		for (Task task : lists.keySet()) {
			int indexToUpdate = data.getTaskList().indexOf(task);
			data.getTaskList().get(indexToUpdate).setgCalId(lists.get(task));
			data.getTaskList().get(indexToUpdate).setLastServerUpdate(System.currentTimeMillis());
		}
		data.updateStorage();

	}

	/**
	 * This function takes in HashMap of Task and Long, It takes the
	 * value(LastServerUpdateTime) and update its key(Task).
	 * 
	 * @param :
	 *            HashMap of key(Task) and value(Long)(lastServerUpdate) pair.
	 */
	public void updateServerUpdateTime(HashMap<Task, Long> lists) {

		for (Task task : lists.keySet()) {
			int indexToUpdate = data.getTaskList().indexOf(task);
			data.getTaskList().get(indexToUpdate).setLastServerUpdate(lists.get(task));
		}

		data.updateStorage();

	}

	/**
	 * This function updates the local storage with the updated remote task.
	 * 
	 * @param remoteTask
	 *            : latest remote task from google calendar api.
	 */
	public void updateTask(Task remoteTask) {

		Task localTask = this.findTaskByGCalId(remoteTask.getgCalId());
		assert localTask != null; // localTask will be found.
		int indexToUpdate = data.getTaskList().indexOf(localTask);
		data.getTaskList().remove(indexToUpdate);
		data.getTaskList().add(remoteTask);
		data.updateStorage();

	}

```
###### src\application\controller\GoogleCalendarManager.java
``` java

	public com.google.api.services.calendar.Calendar getService() {
		return service;
	}

	public static GoogleCalendarManager getInstance() {
		if (instance == null) {
			instance = new GoogleCalendarManager();
		}

		return instance;
	}

	public void performSync() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				performUpSync();
				performDownSync();
				syncOfflineDeletionRecords();
			}
		}).start();
	}

	private GoogleCalendarManager() {
		try {
			service = getCalendarService();
		} catch (IOException e1) {
			LogManager.getInstance().log(this.getClass().getName(), e1.toString());
		}

	}

	/**
	 * This function syncs records of deletion that happen during offline mode.
	 * It clears its cache if successful.
	 */
	private void syncOfflineDeletionRecords() {
		ArrayList<String> records = getListOfDeletionsRecordsFromFile();

		if (records.size() == 0) {
			return;
		}

		try {
			for (String eventId : records) {
				service.events().delete("primary", eventId).execute();
			}
		} catch (IOException e) {
			return;
		}

		// If success, clear the deletion file.
		File file = new File(DELETION_FILE_NAME);
		assert file.exists() == true;
		file.delete();

	}

	/**
	 * This function get a list of deletions record from Cache.
	 */
	private ArrayList<String> getListOfDeletionsRecordsFromFile() {
		ArrayList<String> records = new ArrayList<String>();

		File file = new File(DELETION_FILE_NAME);

		if (!file.exists()) {
			return records;
		}
		GoogleCalendarUtility.getRecordsFromFile(records, file);

		return records;
	}

	/**
	 * This function retrieves Event from Google Calendar API based on a
	 * syncToken, if syncToken is null , It is the initial full sync.
	 * 
	 * @return : a list of events to be updated to local storage or null if it
	 *         fail.
	 */
	private List<Event> getCalendarEvents() {
		String syncToken = TokenManager.getInstance().getLastToken();
		Calendar.Events.List request = null;
		try {
			request = service.events().list("primary");
		} catch (IOException e1) {
			LogManager.getInstance().log(this.getClass().getName(), e1.toString());
			return null;
		}
		setInitialSyncOrContinuingSync(syncToken, request);
		return getEventsByIterateRequestUsingPageToken(request);
	}

	/**
	 * This function takes in a valid request object, and start retrieving the
	 * events from the google api.
	 * 
	 * @param request
	 *            : valid Calendar.Events.List instance
	 * @return list of events
	 */
	private List<Event> getEventsByIterateRequestUsingPageToken(Calendar.Events.List request) {
		List<Event> items = new ArrayList<Event>();
		String pageToken = null;
		Events events = null;
		do {

			request.setPageToken(pageToken);
			try {
				events = request.execute();
			} catch (GoogleJsonResponseException e) {
				if (e.getStatusCode() == 410) {
					// A 410 status code, "Gone", indicates that the sync token
					// is invalid.
					LogManager.getInstance().log(this.getClass().getName(),
							"Invalid sync token, clearing event store and re-syncing.");
					TokenManager.getInstance().clearToken();

				}
			} catch (IOException e) {
				LogManager.getInstance().log(this.getClass().getName(), e.toString());
				if (e instanceof TokenResponseException) {
					renewAccountCredential();
				}

			}
			if (events != null) {
				items.addAll(retrieveEvents(events));
				pageToken = events.getNextPageToken();
			}
		} while (pageToken != null);

		TokenManager.getInstance().setToken(events.getNextSyncToken());
		return items;
	}

	/**
	 * This function sets the request obj for either initial sync or
	 * continuation sync.
	 * 
	 * @param syncToken
	 *            : null if for intial sync, otherwise the sync token from
	 *            previous sync.
	 * @param request
	 *            : valid Calendar.Events.List instance
	 */
	private void setInitialSyncOrContinuingSync(String syncToken, Calendar.Events.List request) {
		DateTime now = new DateTime(System.currentTimeMillis());
		if (syncToken != null && !syncToken.equals("")) {
			request.setSyncToken(syncToken);
		} else {
			request.setTimeMin(now);
		}
	}

	/**
	 * This function renews the account credential.
	 */
	private void renewAccountCredential() {
		
		TokenManager.getInstance().clearToken();
		GoogleCalendarUtility.recursiveDelete(DATA_STORE_DIR);
		try {
			service = getCalendarService();
		} catch (IOException e1) {

			e1.printStackTrace();
		}
	}

	/**
	 * 
	 */
	private void performDownSync() {
		List<Event> lists = null;
		ArrayList<Task> taskArr = new ArrayList<Task>();
		lists = getCalendarEvents();

		for (Event event : lists) {
			if (!event.getStatus().equals("cancelled")) {
				taskArr.add(GoogleCalendarUtility.mapEventToTask(event));
			} else {
				DataManager.getInstance().deleteTaskByGCalId(event.getId());
			}
		}

		// Compare the downloaded and local lastUpate. depending which one is
		// latest.
		// if server lastUpdate > local , update local
		// if local lastUpdate > server , update server

		for (Task task : taskArr) {

			Task localTask = DataManager.getInstance().findTaskByGCalId(task.getgCalId());
			if (localTask == null) {
				// does not exist in local storage. its a new task. update local
				DataManager.getInstance().addNewTask(task);
			} else {
				// compare lastUpdate here
				if (localTask.getLastServerUpdate() > task.getLastServerUpdate()) {
					// update server
					Event event = GoogleCalendarUtility.mapTaskToEvent(localTask);
					updateGCalEvent(event);

				} else {
					// update local
					DataManager.getInstance().updateTask(task);
				}

			}

		}
	}

	/**
	 * This function updates the Google Calendar Event.
	 * 
	 * @param event
	 *            : Google Calendar Event
	 */
	public void updateGCalEvent(Event event) {
		if (event != null) {
			EventReminder[] reminderOverrides = new EventReminder[] {
					new EventReminder().setMethod("email").setMinutes(24 * 60),
					new EventReminder().setMethod("popup").setMinutes(10) };
			Event.Reminders reminders = new Event.Reminders().setUseDefault(false)
					.setOverrides(Arrays.asList(reminderOverrides));
			event.setReminders(reminders);

			try {
				service.events().update("primary", event.getId(), event).execute();
			} catch (IOException e) {
				LogManager.getInstance().log(this.getClass().getName(), e.toString());
			}
		}
	}

	/**
	 * This function perform sync from local to server.
	 */
	private void performUpSync() {

		performNewTaskSync();
		performUpdatedTaskSync();
	}

	/**
	 * This function perform syncing to server for locally modified task.
	 */
	private void performUpdatedTaskSync() {
		ArrayList<Task> lists = DataManager.getInstance().getListOfModifiedTask();
		HashMap<Task, Long> lastServerUpdateMap = new HashMap<Task, Long>();

		for (Task task : lists) {

			Event event = GoogleCalendarUtility.mapTaskToEvent(task);

			try {
				event = service.events().update("primary", task.getgCalId(), event).execute();
				lastServerUpdateMap.put(task, event.getUpdated().getValue());
			} catch (IOException e) {
				LogManager.getInstance().log(this.getClass().getName(), e.toString());
			}
		}

		DataManager.getInstance().updateServerUpdateTime(lastServerUpdateMap);

	}

	/**
	 * This function syncs all new task that are yet to be sync for the first
	 * time.
	 */
	private void performNewTaskSync() {
		ArrayList<Task> lists = DataManager.getInstance().getListOfUnSyncNonFloatingTasks();
		HashMap<Task, String> hashmap = new HashMap<Task, String>();
		for (Task task : lists) { 

			Event event = GoogleCalendarUtility.mapTaskToEvent(task);

			EventReminder[] reminderOverrides = new EventReminder[] {
					new EventReminder().setMethod("email").setMinutes(24 * 60),
					new EventReminder().setMethod("popup").setMinutes(10), };
			Event.Reminders reminders = new Event.Reminders().setUseDefault(false)
					.setOverrides(Arrays.asList(reminderOverrides));
			event.setReminders(reminders);

			try {
				event = service.events().insert("primary", event).execute();
				hashmap.put(task, event.getId());
			} catch (IOException e) {
				LogManager.getInstance().log(this.getClass().getName(), e.toString());
			}

		}

		DataManager.getInstance().updateGCalId(hashmap);
	}

}
```
###### src\application\controller\GoogleCalendarManagerInterface.java
``` java
import java.io.IOException;

import com.google.api.services.calendar.model.Event;

import application.model.Task;
import application.utils.GoogleCalendarUtility;

public class GoogleCalendarManagerInterface {

	private static GoogleCalendarManagerInterface instance;

	com.google.api.services.calendar.Calendar service;

	private GoogleCalendarManagerInterface() {
		service = GoogleCalendarManager.getInstance().getService();
	}

	public static GoogleCalendarManagerInterface getInstance() {
		if (instance == null) {
			instance = new GoogleCalendarManagerInterface();
		}

		return instance;
	}

	/**
	 * Pre-Condition: Internet is up and quickAddMsg is not null. This function
	 * will call the google quickadd api and return the event created. If
	 * Successful, it will return the Task, otherwise it will return null.
	 * 
	 * @param quickAddMsg
	 *            : quickAdd message
	 * @return Task if successful in creation, or null if fail to create task.
	 */

	public Integer quickAddToGCal(String quickAddMsg) {

		Event createdEvent;
		try {
			createdEvent = service.events().quickAdd("primary", quickAddMsg).execute();
			Task task = GoogleCalendarUtility.mapEventToTask(createdEvent);
			int googleAddSuccess = DataManager.getInstance().addNewTask(task);
			return googleAddSuccess;
		} catch (IOException e) {
			LogManager.getInstance().log(this.getClass().getName(), e.toString());
		}
		return null;
	}

	/**
	 * remove events from Gooogle Calendar by eventId
	 * 
	 * @param eventId
	 *            : Google Calendar Event Id
	 */
	public void removeTaskFromServer(String eventId) {
		if (eventId != null) {
			new Thread(new Runnable() {

				@Override
				public void run() {
					try {
						service.events().delete("primary", eventId).execute();
					} catch (IOException e) {
						e.printStackTrace();
					} catch (NullPointerException e) {

					}
				}
			}).start();
		}
	}

}
```
###### src\application\controller\LogManager.java
``` java
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.text.SimpleDateFormat;

import application.controller.parser.ParserFacade;
import wiremock.org.json.JSONException;
import wiremock.org.json.JSONObject;

public class LogManager {

	private static LogManager instance;
	private static final String LOG_FILE_NAME = "log.txt";
	private static File file;
	private int count = 1;

	public static LogManager getInstance() {

		if (instance == null) {
			instance = new LogManager();
		}

		return instance;

	}

	private LogManager() {
		
		file = new File(LOG_FILE_NAME);
		if (!file.exists()) {
			try {
				file.createNewFile();
			} catch (IOException e) {
				//Change file name
				file = new File(LOG_FILE_NAME + count++);
			}
		}
	}

	public void log(String tag, String msg) {
		
		try {
			SimpleDateFormat df = new SimpleDateFormat(ParserFacade.DATE_FORMAT_TYPE_7);
			JSONObject jObj = new JSONObject();
			jObj.put("Tag", tag);
			jObj.put("Msg", msg);
			jObj.put("Time", df.format(System.currentTimeMillis()));
			FileWriter fileWritter = new FileWriter(file.getName(), true);
			BufferedWriter bw = new BufferedWriter(fileWritter);
			bw.write(jObj.toString());
			bw.newLine();
			bw.close();
		} catch (IOException e) {
			//Change file name
			file = new File(LOG_FILE_NAME + count++);
			
		} catch (JSONException e) {
			assert false;
		}
	}

}
```
###### src\application\controller\parser\CommandParser.java
``` java
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import application.exception.InvalidCommandException;
import application.model.Command;
import application.model.Parameter;
import application.model.Task;

/**
 * This is a singleton class
 *
 * 
 *
 */
public class CommandParser {

	private static final String COMMAND_DEFINITION_SEPERATOR = ":";
	private static final String REGEX_INVERTED_SLASH = "\\\\";
	private static final String SMART_PARSING_DATE_INDICATOR = "@";
	private static final int ERROR_COMMAND_TYPE = -1;
	private static final String REGEX_ATSIGN = " @ | @|@ ";
	private static final String VERTICAL_DASH = "\\|";
	private static final char INVERTED_SLASH = '\\';
	private static CommandParser instance;

	static CommandParser getInstance() {
		if (instance == null) {
			instance = new CommandParser();
		}
		return instance;
	}

	public CommandParser() {
		super();

	}

	/**
	 * This function parse the input command string from the input console.
	 * @param command : string to be parsed.
	 * @return : obj of ArrayList<Command>
	 * @throws InvalidCommandException : when command is invalid.
	 */
	public ArrayList<Command> parseCommand(String command) throws InvalidCommandException {


		ArrayList<Command> cmds = new ArrayList<Command>();
		String cmd;
		String[] text;

		ArrayList<Parameter> parameters = new ArrayList<Parameter>();

		int indexOfFirstSpace = 0;
		int indexOfFirstInvertedSlash = 0;
		boolean passFirstSpace = false;

		// check and find the first space and slash.
		for (int i = 0; i < command.length(); i++) {
			if (command.charAt(i) == ' ' && !passFirstSpace) {
				indexOfFirstSpace = i;
				passFirstSpace = true;
			} else if (command.charAt(i) == INVERTED_SLASH) {
				indexOfFirstInvertedSlash = i;
				break;
			}
		}

		indexOfFirstSpace = getEquivalentIndexForCommandWithoutParameter(command, indexOfFirstSpace);

		if (indexOfFirstSpace == 0) {
			return null;
		}

		cmd = command.substring(0, indexOfFirstSpace);
		int cmdType = mapCommandType(cmd);

		if (cmdType == ERROR_COMMAND_TYPE) {
			throw new InvalidCommandException(command);
		}

		if (!command.contains(VERTICAL_DASH)) {
			performSmartParsing(command, parameters);
		}

		text = extractTextAndPerformParameterParsing(command, parameters, indexOfFirstSpace, indexOfFirstInvertedSlash);
		if (text != null) {
			for (String textEntry : text) {
				cmds.add(new Command(cmdType, trimOffDateIfAny(textEntry), parameters));

			}
		} else {
			cmds.add(new Command(cmdType, "", parameters));
		}

		return cmds;
	}

	private String trimOffDateIfAny(String str) {

		String[] strArr = str.split(REGEX_ATSIGN);
		return strArr[0].trim();

	}

	/**
	 *
	 * This function extracts the command main text and extract its paramter.
	 * @param command : the raw command string.
	 * @param parameters : the lists to store the parsed results
	 * @param indexOfFirstSpace : index of the first space of the command.
	 * @param indexOfFirstInvertedSlash : index of the first inverted slash of the command.
	 * @return
	 */
	private String[] extractTextAndPerformParameterParsing(String command, ArrayList<Parameter> parameters,
			int indexOfFirstSpace, int indexOfFirstInvertedSlash) {
		String splitedText[] = null;
		String text;
		if (indexOfFirstSpace < command.length()) {
			if (isValidCommandWithParameter(indexOfFirstSpace, indexOfFirstInvertedSlash)) {
				text = command.substring(indexOfFirstSpace + 1, indexOfFirstInvertedSlash);

				String parameterStr = command.substring(indexOfFirstInvertedSlash, command.length());
				String[] parameterArr = parameterStr.split(" ");
				extractParameter(parameters, parameterArr);
			} else {

				text = command.substring(indexOfFirstSpace + 1, command.length());
			}
			// For multiple add and done
			splitedText = text.split(VERTICAL_DASH);
		}
		return splitedText;
	}

	/**
	 * This function performs smart parsing syntax.
	 * @param command : the raw command string.
	 * @param parameters : the list to store the parsed results.
	 */
	private void performSmartParsing(String command, ArrayList<Parameter> parameters) {
		if (command.contains(SMART_PARSING_DATE_INDICATOR)) {

			String[] strArr = command.split(REGEX_ATSIGN);
			// use the first at, which the content is at [1]
			// try to find @ if there is any
			String[] strArr2;
			if (strArr.length > 1) {
				strArr2 = strArr[1].split(REGEX_INVERTED_SLASH);

				if (ParserFacade.getInstance().containMultiDate(strArr2[0].trim())) {
					parameters.add(new Parameter(Parameter.START_END_DATE_ARGUMENT_TYPE, strArr2[0].trim()));
				} else {
					parameters.add(new Parameter(Parameter.END_DATE_ARGUMENT_TYPE, strArr2[0].trim()));
				}
			}

		}
	}

	/**
	 * This function finds the equivalent index of the first space for command without paramters(which is the space after the command).
	 * @param command : Raw command string.
	 * @return the equivalent index of the first space.
	 */
	private int getEquivalentIndexForCommandWithoutParameter(String command, int indexOfFirstSpace) {

		// check if is a list command with no parameter. e.g list
		if (isCommandType(Command.LIST_COMMAND, command.trim())) {
			indexOfFirstSpace = command.length();
		}

		if (isCommandType(Command.LIST_NEXT_COMMAND, command.trim())) {
			indexOfFirstSpace = command.length();
		}

		if (isCommandType(Command.LIST_TODAY_COMMAND, command.trim())) {
			indexOfFirstSpace = command.length();
		}

		if (isCommandType(Command.HELP_COMMAND, command.trim())) {
			indexOfFirstSpace = command.length();
		}

		if (isCommandType(Command.SCHEDULE_COMMAND, command.trim())) {
			indexOfFirstSpace = command.length();
		}

		if (isCommandType(Command.UNDO_COMMAND, command.trim())) {
			indexOfFirstSpace = command.length();
		}
		return indexOfFirstSpace;
	}


	/**
	 * This function convert the an add command into Task.
	 * @param cmd
	 * @return
	 */
	public Task convertAddCommandtoTask(Command cmd) {

		assert cmd != null;
		Task task = new Task(cmd.getTextContent());
		ArrayList<Parameter> lists = cmd.getParameter();

		for (Parameter para : lists) {
			if (para.getParaType() == Parameter.START_DATE_ARGUMENT_TYPE) {

				task.setStart_date(DateParser.getInstance().parseDate(para.getParaArg()));

			} else if (para.getParaType() == Parameter.START_END_DATE_ARGUMENT_TYPE) {

				List<Date> listsOfDate = DateParser.getInstance().parseMultipleDate(para.getParaArg());
				task.setStart_date(listsOfDate.get(0));
				task.setEnd_date(listsOfDate.get(1));

			} else if (para.getParaType() == Parameter.END_DATE_ARGUMENT_TYPE) {

				task.setEnd_date(DateParser.getInstance().parseDate(para.getParaArg()));

			} else if (para.getParaType() == Parameter.PLACE_ARGUMENT_TYPE) {
				task.setPlace_argument(para.getParaArg());
			} else if (para.getParaType() == Parameter.PRIORITY_ARGUMENT_TYPE) {
				task.setPriority_argument(para.getParaArg());
			} else if (para.getParaType() == Parameter.TYPE_ARGUMENT_TYPE) {
				task.setType_argument(para.getParaArg());
			}
		}

		return task;

	}

	/**
	 *
	 * @param indexOfFirstSpace
	 * @param indexOfFirstInvertedSlash
	 * @return True if the command is with parameter, else false.
	 */
	private boolean isValidCommandWithParameter(int indexOfFirstSpace, int indexOfFirstInvertedSlash) {
		return indexOfFirstInvertedSlash > 0 && indexOfFirstInvertedSlash > indexOfFirstSpace;
	}

	/**
	 * This function will convert raw parameter and add it into arraylist of
	 * parameter.
	 *
	 * @param parameters
	 *            : arraylist to store extracted parameter
	 * @param parameterArr
	 *            : raw parameter string to convert into parameter instance.
	 */
	private void extractParameter(ArrayList<Parameter> parameters, String[] parameterArr) {
		for (int i = 0; i < parameterArr.length; i++) {
			if (parameterArr[i].charAt(0) == INVERTED_SLASH) {

				// format.
				String para = parameterArr[i].substring(1, parameterArr[i].length());
				// If the next parameter charAt(0) is not \\, then it going to
				// concat together
				// with this paragraph

				String paraContent = "";

				for (int c = i + 1; c < parameterArr.length; c++) {
					if (parameterArr[c].charAt(0) != INVERTED_SLASH) {
						paraContent += parameterArr[c].substring(0, parameterArr[c].length()) + " ";
					} else {
						break;
					}
				}
				int paraType = mapParameterType(para);
				if (paraType != ERROR_COMMAND_TYPE) {
					parameters.add(new Parameter(paraType, paraContent.trim()));
				}
			}
		}
	}

	/**
	 * Map the command and finds its form.
	 * @param cmd
	 * @return the type of command in integer form.
	 */
	private Integer mapCommandType(String cmd) {

		if (isCommandType(Command.ADD_COMMAND, cmd)) {
			return Command.ADD_COMMAND_TYPE;
		} else if (isCommandType(Command.CHANGE_STORAGE_COMMAND, cmd)) {
			return Command.CHANGE_STORAGE_COMMAND_TYPE;
		} else if (isCommandType(Command.DELETE_COMMAND, cmd)) {
			return Command.DELETE_COMMAND_TYPE;
		} else if (isCommandType(Command.DONE_COMMAND, cmd)) {
			return Command.DONE_COMMAND_TYPE;
		} else if (isCommandType(Command.EDIT_COMMAND, cmd)) {
			return Command.EDIT_COMMAND_TYPE;
		} else if (isCommandType(Command.LIST_COMMAND, cmd)) {
			return Command.LIST_COMMAND_TYPE;
		} else if (isCommandType(Command.UNDO_COMMAND, cmd)) {
			return Command.UNDO_COMMAND_TYPE;
		} else if (isCommandType(Command.SEARCH_COMMAND, cmd)) {
			return Command.SEARCH_COMMAND_TYPE;
		} else if (isCommandType(Command.LIST_TODAY_COMMAND, cmd)) {
			return Command.LIST_TODAY_COMMAND_TYPE;
		} else if (isCommandType(Command.LIST_NEXT_COMMAND, cmd)) {
			return Command.LIST_NEXT_COMMAND_TYPE;
		} else if (isCommandType(Command.HELP_COMMAND, cmd)) {
			return Command.HELP_COMMAND_TYPE;
		} else if (isCommandType(Command.SCHEDULE_COMMAND, cmd)) {
			return Command.SCHEDULE_COMMAND_TYPE;
		} else if (isCommandType(Command.UNDONE_COMMAND, cmd)) {
			return Command.UNDONE_COMMAND_TYPE;
		} else if (isCommandType(Command.GOOGLE_ADD_COMMAND, cmd)) {
			return Command.GOOGLE_ADD_COMMAND_TYPE;
		} else {
			return ERROR_COMMAND_TYPE;
		}

	}

	/**
	 *
	 * @param cmdDefinition : The definition of the command. For e.g "add:+"
	 * @param cmd : the command to check. For E.g. add
	 * @return true if matched, otherwise false.
	 */
	private boolean isCommandType(String cmdDefinition, String cmd) {

		String[] cmdDef = cmdDefinition.split(COMMAND_DEFINITION_SEPERATOR);
		for (int i = 0; i < cmdDef.length; i++) {
			if (cmdDef[i].equals(cmd)) {
				return true;
			}
		}
		return false;

	}

	/**
	 * This functions maps the parameters with its type.
	 * @param parameterStr
	 * @return its type in integer form.
	 */
	private Integer mapParameterType(String parameterStr) {

		switch (parameterStr) {

		case Parameter.PRIORITY_ARGUMENT:
			return Parameter.PRIORITY_ARGUMENT_TYPE;

		case Parameter.START_DATE_ARGUMENT:
			return Parameter.START_DATE_ARGUMENT_TYPE;

		case Parameter.PLACE_ARGUMENT:
			return Parameter.PLACE_ARGUMENT_TYPE;
		case Parameter.END_DATE_ARGUMENT:
			return Parameter.END_DATE_ARGUMENT_TYPE;
		case Parameter.TYPE_ARGUMENT:
			return Parameter.TYPE_ARGUMENT_TYPE;

		default:
			return ERROR_COMMAND_TYPE;

		}

	}

}
```
###### src\application\controller\parser\DateParser.java
``` java
import java.util.Date;
import java.util.List;

import com.joestelmach.natty.DateGroup;
import com.joestelmach.natty.Parser;

public class DateParser {

	private static DateParser instance;

	private DateParser() {

	}

	static DateParser getInstance() {
		if (instance == null) {
			instance = new DateParser();
		}
		return instance;
	}

	/**
	 * This function parses a string containing a single date.
	 * @param dateStr : date in string format.
	 * @return Date object
	 */
	public Date parseDate(String dateStr) {

		if (isUKFormat(dateStr)) {

			return UKDateParser.getInstance().parseDate(dateStr);

		} else {

			List<Date> lists = null;
			Parser parser = new Parser();
			List<DateGroup> groups = parser.parse(dateStr);
			for (DateGroup group : groups) {
				lists = group.getDates();
			}
			return lists.get(0);

		}

	}

	/**
	 * This function check if the date is in UK format.
	 * @param dateStr : date in string object.
	 * @return true if the date is in uk format, else false.
	 */
	private boolean isUKFormat(String dateStr) {
		return dateStr.contains("/");
	}

	
	/**
	 * This function parse a string containing multiple date. For e.g "today to next wednesday"
	 * @param dateStr : date in string object.
	 * @return : a list of date object. Contains only two object.
	 */
	public List<Date> parseMultipleDate(String dateStr) {

		List<Date> lists = null;
		Parser parser = new Parser();
		List<DateGroup> groups = parser.parse(dateStr);
		for (DateGroup group : groups) {
			lists = group.getDates();
		}
		return lists;

	}

	/**
	 * This function checks if the date contain multiple date.
	 * @param dateStr : date in string object.
	 * @return return true if contains multiple date, else false.
	 */
	public boolean containMultipleDate(String dateStr) {

		List<Date> lists = null;
		Parser parser = new Parser();
		List<DateGroup> groups = parser.parse(dateStr);
		for (DateGroup group : groups) {
			lists = group.getDates();
		}
		return lists.size() > 1;

	}

}
```
###### src\application\controller\parser\ParserFacade.java
``` java
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import application.exception.InvalidCommandException;
import application.model.Command;
import application.model.Task;

public class ParserFacade {

	private static ParserFacade instance;

	// From 1 to 99, after and on yyyy are all virtual, user does not type them.
	// It is used to facilitate parsing.
	public static final String DATE_FORMAT_TYPE_1 = "dd/MM hha yyyy";
	public static final String DATE_FORMAT_TYPE_2 = "dd/MM yyyy";
	public static final String DATE_FORMAT_TYPE_3 = "dd/MM hh:mma yyyy";
	public static final String DATE_FORMAT_TYPE_4 = "dd/MM HH:mm yyyy";
	public static final String DATE_FORMAT_TYPE_5 = "hha dd/MM yyyy";
	public static final String DATE_FORMAT_TYPE_6 = "hh:mma dd/MM yyyy";
	public static final String DATE_FORMAT_TYPE_7 = "HH:mm dd/MM yyyy";

	// From 100 onward, it is normal parsing, user type as expected.
	public static final String DATE_FORMAT_TYPE_100 = "dd/MM/yy HH:mm";
	public static final String DATE_FORMAT_TYPE_101 = "dd/MM/yy hh:mma";
	public static final String DATE_FORMAT_TYPE_102 = "dd.MM.yy HH:mm";
	public static final String DATE_FORMAT_TYPE_103 = "dd.MM.yy hh:mma";
	public static final String DATE_FORMAT_TYPE_104 = "dd/MM/yy hha";
	public static final String DATE_FORMAT_TYPE_105 = "dd.MM.yy hha";

	public static final String DATE_FORMAT_TYPE_106 = "HH:mm dd/MM/yy";
	public static final String DATE_FORMAT_TYPE_107 = "hh:mma dd/MM/yy";
	public static final String DATE_FORMAT_TYPE_108 = "HH:mm dd.MM.yy";
	public static final String DATE_FORMAT_TYPE_109 = "hh:mma dd.MM.yy";
	public static final String DATE_FORMAT_TYPE_110 = "hha dd/MM/yy";
	public static final String DATE_FORMAT_TYPE_111 = "hha dd.MM.yy";

	public static final String DATE_FORMAT_TYPE_200 = "hh:mma";

	private ParserFacade() {

	}

	public static ParserFacade getInstance() {
		if (instance == null) {
			instance = new ParserFacade();
		}
		return instance;
	}

	public Date parseDate(String dateStr) {
		return DateParser.getInstance().parseDate(dateStr);
	}

	public List<Date> parseMultiDate(String dateStr) {
		return DateParser.getInstance().parseMultipleDate(dateStr);
	}

	public boolean containMultiDate(String dateStr) {
		return DateParser.getInstance().containMultipleDate(dateStr);
	}

	public ArrayList<Command> parseCommand(String command) throws InvalidCommandException {
		return CommandParser.getInstance().parseCommand(command);
	}

	public Task convertAddCommandtoTask(Command cmd) {
		return CommandParser.getInstance().convertAddCommandtoTask(cmd);
	}

}
```
###### src\application\controller\parser\UKDateParser.java
``` java
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;

public class UKDateParser {

	public static final int ONE_WEEK_IN_MS = 86400 * 7 * 1000;
	ArrayList<String> listsOfDateFormat;
	private static UKDateParser instance;

	private UKDateParser() {
		initListsOfDateFormat();

	}

	/**
	 * 
	 */
	private void initListsOfDateFormat() {
		listsOfDateFormat = new ArrayList<String>();
		listsOfDateFormat.add(ParserFacade.DATE_FORMAT_TYPE_1);
		listsOfDateFormat.add(ParserFacade.DATE_FORMAT_TYPE_2);
		listsOfDateFormat.add(ParserFacade.DATE_FORMAT_TYPE_3);
		listsOfDateFormat.add(ParserFacade.DATE_FORMAT_TYPE_4);
		listsOfDateFormat.add(ParserFacade.DATE_FORMAT_TYPE_5);
		listsOfDateFormat.add(ParserFacade.DATE_FORMAT_TYPE_6);
		listsOfDateFormat.add(ParserFacade.DATE_FORMAT_TYPE_7);
		
		listsOfDateFormat.add(ParserFacade.DATE_FORMAT_TYPE_100);
		listsOfDateFormat.add(ParserFacade.DATE_FORMAT_TYPE_101);
		listsOfDateFormat.add(ParserFacade.DATE_FORMAT_TYPE_102);
		listsOfDateFormat.add(ParserFacade.DATE_FORMAT_TYPE_103);
		listsOfDateFormat.add(ParserFacade.DATE_FORMAT_TYPE_104);
		listsOfDateFormat.add(ParserFacade.DATE_FORMAT_TYPE_105);
		listsOfDateFormat.add(ParserFacade.DATE_FORMAT_TYPE_106);
		listsOfDateFormat.add(ParserFacade.DATE_FORMAT_TYPE_107);
		listsOfDateFormat.add(ParserFacade.DATE_FORMAT_TYPE_108);
		listsOfDateFormat.add(ParserFacade.DATE_FORMAT_TYPE_109);
		listsOfDateFormat.add(ParserFacade.DATE_FORMAT_TYPE_110);
		listsOfDateFormat.add(ParserFacade.DATE_FORMAT_TYPE_111);
	}

	static UKDateParser getInstance() {
		if (instance == null) {
			instance = new UKDateParser();
		}
		return instance;
	}

	/**
	 * This function parse the date using the listsOfDateFormat, it try one by one
	 * until one is matched.
	 * @param dateStr : date in string object.
	 * @return The Date instance if parsing is successful. 
	 */
	public Date parseDate(String dateStr) {

		DateFormat df1;
		Date date = null;
		int count = 1;
		boolean isNextWeek = false;

		if (dateStr.toUpperCase().contains("NEXT")) {

			isNextWeek = true;

			dateStr = dateStr.replaceAll("(?i)next", "").trim();

		}

		for (String type : this.listsOfDateFormat) {

			df1 = new SimpleDateFormat(type);
			df1.setLenient(false);

			String tmpDate = "";
			if (count <= 7) {
				tmpDate = dateStr + " " + Calendar.getInstance().get(Calendar.YEAR);
			} else {
				tmpDate = dateStr;
			}

			// 3 is the max char difference allowance.
			if (tmpDate.length() <= type.length() + 3) {
				try {

					date = df1.parse(tmpDate);

					break;
				} catch (ParseException e) {
					// continue parsing
				}
			}
			count++;

		}

		// Modified the current set date to next week of that date
		if (isNextWeek) {
			long plusOneWeekTime = date.getTime() + ONE_WEEK_IN_MS;
			date = new Date(plusOneWeekTime);
		}

		return date;
	}

}
```
###### src\application\exception\InvalidCommandException.java
``` java
@SuppressWarnings("serial")
public class InvalidCommandException extends Exception {

	String msg = "";

	public InvalidCommandException(String msg) {
		this.msg = msg;
	}

	@Override
	public String getMessage() {
		
		return "Invalid command : \"" + msg + "\"";
	}

}
```
###### src\application\exception\ParseDateException.java
``` java
@SuppressWarnings("serial")
public class ParseDateException extends Exception {

	String date;

	public ParseDateException(String date) {
		this.date = date;
	}

	@Override
	public String getMessage() {
		return "Unable to parse \"" + date + "\"";
	}

}
```
###### src\application\Main.java
``` java
import java.awt.AWTException;
import java.awt.Image;
import java.awt.MenuItem;
import java.awt.PopupMenu;
import java.awt.SystemTray;
import java.awt.TrayIcon;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.net.URL;
import javax.swing.ImageIcon;



import application.controller.GoogleCalendarManager;
import application.controller.LogManager;
import application.utils.GoogleCalendarUtility;
import application.view.UIController;
import javafx.application.Application;
import javafx.application.Platform;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.stage.Stage;

public class Main extends Application {

	boolean firstTime;
	private TrayIcon trayIcon;
	public Stage stage;

	@Override
	public void start(Stage primaryStage) {

		try {
			FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource("UI.fxml"));
			UIController uiControl = UIController.getInstance();

			fxmlLoader.setController(uiControl);

			Parent root = fxmlLoader.load();
			Scene scene = new Scene(root, 1000, 600); 
			scene.getStylesheets().add(getClass().getResource("application.css").toExternalForm());
			primaryStage.setScene(scene);
			primaryStage.setTitle("toDoo");
			primaryStage.getIcons().add(new javafx.scene.image.Image(getClass().getResourceAsStream("toDoo.png")));
			uiControl.setMainApp(this);
			firstTime = true;
			Platform.setImplicitExit(false);
			primaryStage.show();

			createAndShowGUI();
			this.stage = primaryStage; 

			if (GoogleCalendarUtility.hasInternetConnection()) {
				GoogleCalendarManager.getInstance().performSync();
			}
			
			UIController.getInstance().processManualRequest("today");
			

		} catch (Exception e) {
			e.printStackTrace();
		}

	}

	public static void main(String[] args) {

		launch(args);

	}

	/**
	 * @@Java DISCLAIMER: this code is adapted from java official code examples.
	 */
	private void createAndShowGUI() {
		// Check the SystemTray support
		if (!SystemTray.isSupported()) {
			LogManager.getInstance().log(this.getClass().getName(), "SystemTray is not supported");
		
			return;
		}
		final PopupMenu popup = new PopupMenu();
		trayIcon = new TrayIcon(createImage("toDoo.png", "tray icon"));
		final SystemTray tray = SystemTray.getSystemTray();

		MenuItem exitItem = new MenuItem("Exit");

		popup.add(exitItem);

		trayIcon.setPopupMenu(popup);

		try {
			tray.add(trayIcon);
		} catch (AWTException e) {
			LogManager.getInstance().log(this.getClass().getName(), "TrayIcon could not be added.");
			
			return;
		}

		trayIcon.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent e) {
				Platform.runLater(new Runnable() {
					@Override
					public void run() {
						stage.show();
						UIController.getInstance().clearConsole();
						UIController.getInstance().processManualRequest("today");						
					}
				});

			}
		});

		exitItem.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent e) { 
				try {
					tray.remove(trayIcon);
				
				} catch (Exception err) {
					LogManager.getInstance().log(this.getClass().getName(), err.toString());
				}
				System.exit(0);

			}
		});
	}

	// Obtain the image URL
	protected static Image createImage(String path, String description) {

		URL imageURL = Main.class.getResource(path);

		if (imageURL == null) {
			System.err.println("Resource not found: " + path);
			return null;
		} else {
			return (new ImageIcon(imageURL, description)).getImage();
		}
	}

}
```
###### src\application\model\Command.java
``` java
import java.util.ArrayList;

public class Command {

	public static final String ADD_COMMAND = "add:+";
	public static final String LIST_COMMAND = "list:ls";
	public static final String CHANGE_STORAGE_COMMAND = "changeStorage:cs";
	public static final String DELETE_COMMAND = "delete:-";
	public static final String UNDO_COMMAND = "undo:<";
	public static final String EDIT_COMMAND = "edit:et";
	public static final String DONE_COMMAND = "done:ok";
	public static final String UNDONE_COMMAND = "notdone:notok";
	public static final String SEARCH_COMMAND = "search:s";
	public static final String LIST_TODAY_COMMAND = "today:now";
	public static final String LIST_NEXT_COMMAND = "next:nxt";
	public static final String HELP_COMMAND = "help:?";
	public static final String SCHEDULE_COMMAND = "schedule:sd";
	public static final String GOOGLE_ADD_COMMAND = "googleAdd:ga";

	public static final int ADD_COMMAND_TYPE = 1;
	public static final int LIST_COMMAND_TYPE = 2;
	public static final int CHANGE_STORAGE_COMMAND_TYPE = 3;
	public static final int DELETE_COMMAND_TYPE = 4;
	public static final int UNDO_COMMAND_TYPE = 5;
	public static final int EDIT_COMMAND_TYPE = 6;
	public static final int DONE_COMMAND_TYPE = 7;
	public static final int UNDONE_COMMAND_TYPE = 8;
	public static final int SEARCH_COMMAND_TYPE = 9;
	public static final int LIST_TODAY_COMMAND_TYPE = 10;
	public static final int LIST_NEXT_COMMAND_TYPE = 11;
	public static final int HELP_COMMAND_TYPE = 12;
	public static final int SCHEDULE_COMMAND_TYPE = 13;
	public static final int GOOGLE_ADD_COMMAND_TYPE = 14;

	private Integer type;
	private String textContent;
	private ArrayList<Parameter> parameters;

	public Command(Integer type, String textContent, ArrayList<Parameter> parameter) {
		super();
		this.type = type;
		this.textContent = textContent;
		this.parameters = parameter;
	}

	public Integer getType() {
		return type;
	}

	public void setType(Integer type) {
		this.type = type;
	}

	public String getTextContent() {
		return textContent;
	}

	public void setTextContent(String textContent) {
		this.textContent = textContent;
	}

	public ArrayList<Parameter> getParameter() {
		return parameters;
	}

	public void setParameter(ArrayList<Parameter> parameter) {
		this.parameters = parameter;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see java.lang.Object#equals(java.lang.Object)
	 */
	@Override
	public boolean equals(Object obj) {

		if (obj instanceof Command) {
			Command cmd = (Command) obj;
			if (this.parameters.containsAll(cmd.getParameter()) && cmd.getParameter().containsAll(this.parameters)
					&& this.textContent.equals(cmd.getTextContent()) && this.type == cmd.type) {
				return true;
			} else {
				return false;
			}
		}

		return super.equals(obj);
	}

}
```
###### src\application\model\Parameter.java
``` java
public class Parameter {

	public static final String PRIORITY_ARGUMENT = "p";
	public static final String TYPE_ARGUMENT = "t";
	public static final String START_DATE_ARGUMENT = "sdate";
	public static final String END_DATE_ARGUMENT = "edate";

	public static final String START_END_DATE_ARGUMENT = "date";

	public static final String PLACE_ARGUMENT = "place";

	public static final int PRIORITY_ARGUMENT_TYPE = 1;
	public static final int TYPE_ARGUMENT_TYPE = 2;
	public static final int START_DATE_ARGUMENT_TYPE = 3;
	public static final int END_DATE_ARGUMENT_TYPE = 4;
	public static final int PLACE_ARGUMENT_TYPE = 5;
	public static final int START_END_DATE_ARGUMENT_TYPE = 6;

	private int type;
	private String argument;

	public Parameter(int type, String argument) {
		this.type = type;
		this.argument = argument;
	}

	public String getParaArg() {
		return argument;
	}

	public int getParaType() {
		return type;
	}

	@Override
	public boolean equals(Object obj) {

		if (obj instanceof Parameter) {
			Parameter nObj = (Parameter) obj;
			if (nObj.getParaArg().equals(this.argument) && nObj.getParaType() == this.type) {
				return true;
			} else {
				return false;
			}
		} else {
			return super.equals(obj);
		}
	}

}
```
###### src\application\model\Task.java
``` java
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;

import application.controller.parser.ParserFacade;

public class Task implements Comparable<Task> {

	private String textContent;

	private boolean isDone;
	private String priority_argument;
	private String type_argument;
	private Date start_date;
	private Date end_date;
	private String place_argument;

	private String gCalId = "";

	/**
	 * @return the gCalId
	 */
	public String getgCalId() {
		return gCalId;
	}

	/**
	 * @param gCalId
	 *            the gCalId to set
	 */
	public void setgCalId(String gCalId) {
		this.gCalId = gCalId;
	}

	/**
	 * @return the lastUpdate
	 */
	public long getLastServerUpdate() {
		return lastServerUpdate;
	}

	/**
	 * @param lastUpdate
	 *            the lastUpdate to set
	 */
	public void setLastServerUpdate(long lastUpdate) {
		this.lastServerUpdate = lastUpdate;
	}

	private long lastServerUpdate;
	private long lastLocalUpdate;

	/**
	 * @return the lastLocalUpdate
	 */
	public long getLastLocalUpdate() {
		return lastLocalUpdate;
	}

	/**
	 * @param lastLocalUpdate
	 *            the lastLocalUpdate to set
	 */
	public void setLastLocalUpdate(long lastLocalUpdate) {
		this.lastLocalUpdate = lastLocalUpdate;
	}

	public Task() {
		isDone = false;
		textContent = new String("");
		priority_argument = new String("normal");
		type_argument = new String("normal");
		place_argument = new String("");
		start_date = null;
		end_date = null;
	}

	public Task(String textContent) {
		this.textContent = textContent;
		isDone = false;
		textContent = new String("");
		priority_argument = new String("normal");
		type_argument = new String("normal");
		place_argument = new String("");
		start_date = null;
		end_date = null;
	}

	public boolean isDone() {
		return isDone;
	}

	public void setDone(boolean isDone) {
		this.isDone = isDone;
	}

	public String getTextContent() {
		return textContent;
	}

	public void setTextContent(String textContent) {
		if (textContent != null) {
			this.textContent = textContent;
		} else {
			this.textContent = "";
		}
	}

	public String getPriority_argument() {
		return priority_argument;
	}

	public void setPriority_argument(String priority_argument) {
		if (priority_argument != null) {
			this.priority_argument = priority_argument;
		} else {
			this.priority_argument = "normal";
		}
	}

	public String getType_argument() {
		return type_argument;
	}

	public void setType_argument(String type_argument) {
		if (type_argument != null) {
			this.type_argument = type_argument;
		} else {
			this.type_argument = "normal";
		}
	}

	public Date getStart_date() {
		return start_date;
	}

	public void setStart_date(Date start_date) {
		this.start_date = start_date;
	}

	public Date getEnd_date() {
		return end_date;
	}

	public void setEnd_date(Date end_date) {
		this.end_date = end_date;
	}

	public String getPlace_argument() {
		return place_argument;
	}

	public void setPlace_argument(String place_argument) {
		if (place_argument != null) {
			this.place_argument = place_argument;
		} else {
			this.place_argument = "";
		}
	}

	

	@Override
	public int compareTo(Task task) {
		try {
			return getEnd_date().compareTo(task.getEnd_date());
		} catch (NullPointerException ex) {
			if (this.getEnd_date() == null) {
				return 1;
			} else {
				return -1;
			}
		}
	}

	@Override
	public boolean equals(Object obj) {
	
		if (obj instanceof Task) {
			boolean isDateEq1, isDateEq2;
			Task taskCmp = (Task) obj;
			if (this.isDone == taskCmp.isDone && this.place_argument.equals(taskCmp.getPlace_argument())
					&& this.priority_argument.equals(taskCmp.getPriority_argument())
					&& this.textContent.equals(taskCmp.getTextContent())
					&& this.type_argument.equals(taskCmp.getType_argument())
					&& (this.lastServerUpdate == taskCmp.getLastServerUpdate())) {

				if (this.start_date != null && taskCmp.getStart_date() != null) {
					if (this.start_date.equals(taskCmp.getStart_date())) {
						isDateEq1 = true;
					} else {
						isDateEq1 = false;
					}
				}else{
					if (this.start_date == null && taskCmp.getStart_date() == null){
						isDateEq1 = true;
					}else{
						isDateEq1 = false;
					}
				}

				if (this.end_date != null && taskCmp.getEnd_date() != null) {
					if (this.end_date.equals(taskCmp.getEnd_date())) {
						isDateEq2 = true;
					} else {
						isDateEq2 = false;
					}
				}else{
					if (this.end_date == null && taskCmp.getEnd_date() == null){
						isDateEq2 = true;
					}else{
						isDateEq2 = false;
					}
				}

				return (isDateEq1 && isDateEq2);
			} else {
				return false;
			}

		}

		return super.equals(obj);
	}

	public String getEDateInStr(String type) {

		DateFormat df1 = new SimpleDateFormat(type);
		String dateStr = df1.format(this.getEnd_date());
		return dateStr;
	}

	public String getSDateInStr(String type) {

		DateFormat df1 = new SimpleDateFormat(type);
		String dateStr = df1.format(this.getStart_date());
		return dateStr;
	}
	
	/**
	 * @param task
	 * @return
	 */
	public boolean isModified() {
		return this.getgCalId() != null && !this.getgCalId().equals("") && this.getLastServerUpdate() != 0
				&& this.getLastLocalUpdate() != 0 && (this.getLastLocalUpdate() > this.getLastServerUpdate());
	}
	
	/**
	 * This function will determine if task is non-floating.
	 * @param task
	 * @return return true if task is non-floating else false.
	 */
	public boolean isNonFloatingTask() {
		return this.getEnd_date() != null;
	}

	/**This function will determine if task is yet to be synced.
	 * Pre-condition: task is not null.
	 * @param task
	 * @return return true if task is not yet synced, else false.
	 */
	public boolean isUnSyncedTask() {
		return this.getgCalId() != null && this.getgCalId().equals("");
	}
	
	/**
	 * This function will check if this task 
	 * @return
	 */
	private boolean isSyncedBefore() {
		return this.getgCalId() != null && !this.getgCalId().equals("");
	}

	/**
	 * This function compares if this task gCalId is the same.
	 * @param gCalId
	 * @return if gCalId is the same.
	 */
	public boolean compareGCalId(String gCalId) {
		return this.isSyncedBefore() && this.getgCalId().equals(gCalId);
	}
	
	@Override
	public String toString() {

		StringBuilder sb = new StringBuilder();
		sb.append("Description: " + this.textContent);
		if (!this.type_argument.equals("")) {
			sb.append(" Type: " + this.type_argument);
		}
		if (!this.priority_argument.equals("")) {
			sb.append(" Priority: " + this.priority_argument);
		}

		if (!this.place_argument.equals("")) {
			sb.append(" Location: " + this.place_argument);
		}

		if (this.start_date != null) {
			sb.append(" Start Date: " + this.getSDateInStr(ParserFacade.DATE_FORMAT_TYPE_1));

		}

		if (this.end_date != null) {
			sb.append(" End date : " + this.getEDateInStr(ParserFacade.DATE_FORMAT_TYPE_1));
		}

		return sb.toString();
	}

}
```
###### src\application\utils\GoogleCalendarUtility.java
``` java
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URL;
import java.net.URLConnection;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import com.google.api.client.util.DateTime;
import com.google.api.services.calendar.model.Event;
import com.google.api.services.calendar.model.EventDateTime;
import com.google.api.services.calendar.model.Event.ExtendedProperties;

import application.controller.GoogleCalendarManager;
import application.model.Task;

public class GoogleCalendarUtility {

	public static boolean hasInternetConnection() {
		try {
			URL urlObj = new URL("http://www.google.com");
			URLConnection connection = urlObj.openConnection();
			connection.connect();
			return true;
		} catch (IOException e) {
			return false;
		}

	}

```
###### src\application\utils\GoogleCalendarUtility.java
``` java
	/**
	 * This function maps Task to Event Object.
	 * 
	 * @param task
	 *            : toDoo task model.
	 * @return Google Calendar Event object.
	 */
	public static Event mapTaskToEvent(Task task) {
		Event event = new Event().setSummary(task.getTextContent()).setLocation(task.getPlace_argument())
				.setDescription(task.getPriority_argument());
		Map<String, String> hashMap = new HashMap<String, String>();
		hashMap.put("type", task.getType_argument());

		if (!task.getgCalId().equals("")) {
			event.setId(task.getgCalId());
		}

		EventDateTime start = new EventDateTime();
		if (task.getStart_date() != null) {
			start.setDateTime(new DateTime(task.getStart_date()));
		}

		EventDateTime end = new EventDateTime();
		if (task.getEnd_date() != null) {
			end.setDateTime(new DateTime(task.getEnd_date()));

		}

		EventDateTime endMinus1Hr = new EventDateTime();
		endMinus1Hr.setDateTime(new DateTime(new Date(task.getEnd_date().getTime() - 3600000)));

		if (task.getStart_date() == null) {
			event.setStart(endMinus1Hr);
			event.setEnd(end);
			hashMap.put("has_start_date", "no");
			ExtendedProperties prop = new ExtendedProperties();
			prop.setShared(hashMap);
			event.setExtendedProperties(prop);

		} else {
			event.setStart(start);
			event.setEnd(end);
			hashMap.put("has_start_date", "yes");
			ExtendedProperties prop = new ExtendedProperties();
			prop.setShared(hashMap);
			event.setExtendedProperties(prop);
		}

		return event;
	}

	/**
	 * This function maps Event Object to Task Object
	 * 
	 * @param event
	 *            : Google Calendar Event Object
	 */
	public static Task mapEventToTask(Event event) {

		Task tmpTask = new Task();

		tmpTask.setTextContent(event.getSummary());

		if (event.getExtendedProperties() != null && event.getExtendedProperties().getShared() != null) {
			tmpTask.setType_argument(event.getExtendedProperties().getShared().get("type"));
		}

		tmpTask.setPriority_argument(event.getDescription());

		tmpTask.setPlace_argument(event.getLocation());
		tmpTask.setLastServerUpdate(event.getUpdated().getValue());
		tmpTask.setgCalId(event.getId());
		String has_start_date = null;
		ExtendedProperties prop = event.getExtendedProperties();
		Map<String, String> hash = null;
		if (prop != null) {
			hash = prop.getShared();
		}

		if (hash != null) {
			has_start_date = hash.get("has_start_date");
		}

		if (has_start_date == null) {
			has_start_date = "yes";
		}

		if (event.getStart() != null && has_start_date.equals("yes")) {
			DateTime dt = event.getStart().getDate();
			if (dt == null) {
				dt = event.getStart().getDateTime();
			}
			tmpTask.setStart_date(new Date(dt.getValue()));
		} else {
			tmpTask.setStart_date(null);
		}

		if (event.getEnd() != null) {
			DateTime dt = event.getEnd().getDate();
			if (dt == null) {
				dt = event.getEnd().getDateTime();
			}
			tmpTask.setEnd_date(new Date(dt.getValue()));
		}

		return tmpTask;
	}

	/**
	 * This function take in a arraylist of records, and store the data into the
	 * file to the records.
	 * 
	 * @param records
	 *            : the place to be store in.
	 * @param file
	 *            : the file to be read from.
	 */
	public static void getRecordsFromFile(ArrayList<String> records, File file) {
		FileInputStream fIn = null;
		try {
			fIn = new FileInputStream(file);
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
		BufferedReader myReader = new BufferedReader(new InputStreamReader(fIn));
		String aDataRow = "";

		try {
			while ((aDataRow = myReader.readLine()) != null) {
				records.add(aDataRow);
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
		try {
			myReader.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	/**
	 * This function will add the eventId to its deletion records.
	 * 
	 * @param eventId
	 *            : Google Calendar Event Id.
	 */
	public static void addToOfflineDeletionRecords(String eventId) {
		if (eventId != null) {
			try {

				File file = new File(GoogleCalendarManager.DELETION_FILE_NAME);
				if (!file.exists()) {
					file.createNewFile();
				}

				FileWriter fileWritter = new FileWriter(file.getName(), true);
				BufferedWriter bw = new BufferedWriter(fileWritter);
				bw.write(eventId);
				bw.newLine();
				bw.close();
			} catch (IOException e) {
				e.printStackTrace();
			} catch (NullPointerException e) {

			}
		}

	}

```
###### src\application\utils\TasksFormatter.java
``` java
	private static String replaceWithDotIfTooLong(String string, int limit){

		if(string.length() > (limit * 0.7)){
			return string.substring(0, (int)(limit * 0.7)) + "..";

		}
		return string;
	}


}
```
###### src\application\utils\TokenManager.java
``` java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

public class TokenManager {

	private static TokenManager instance;
	private static final String DEFAULT_TOKEN_PATH = "token.txt";
	File file;

	private TokenManager() {
		file = new File(DEFAULT_TOKEN_PATH); 
	}

	public static TokenManager getInstance() {
		if (instance == null) {
			instance = new TokenManager();
		}

		return instance;
	}

	/**
	 * This function gets the last saved token.
	 * @return return the last saved token.
	 */
	public String getLastToken() {

		try {
			if (!file.exists()) {
				return null;
			} else {

				FileInputStream fIn = new FileInputStream(file);
				BufferedReader myReader = new BufferedReader(new InputStreamReader(fIn));
				String token = myReader.readLine();

				myReader.close();
				return token;
			}
		} catch (Exception e) {
			e.printStackTrace();
		}

		return null;

	}
	
	public void clearToken(){
		setToken("");
	}

	/**
	 * This function sets token into local cache.
	 * @param token : token in string format.
	 * @return true if token is set, else false
	 */
	public boolean setToken(String token) {

		try {
			BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file)));
			bw.write(token);
			bw.close();
			return true;

		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}

		return false;

	}

}
```
###### src\application\view\UIController.java
``` java


import application.Main;
import application.controller.GoogleCalendarManager;
import application.controller.LogicController;
import application.exception.InvalidCommandException;
import application.utils.GoogleCalendarUtility;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.scene.control.Button;
import javafx.scene.control.MenuItem;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextField;
import javafx.scene.input.MouseEvent;

public class UIController {
	@FXML
	private MenuItem minimizeMenuItem;
	@FXML
	private Button btSend;
	@FXML
	private TextField textCommandInput;
	@FXML
	private TextArea textConsoleOutput;

	Main mainApp;

	private static UIController instance;

	public static UIController getInstance() {
		if (instance == null) {
			instance = new UIController();
		}
		return instance;
	}

	private UIController() {  
		
	}

	public void setMainApp(Main app) {
		this.mainApp = app;

	}


	// Event Listener on MenuItem[#minimizeMenuItem].onAction
	@FXML
	public void onMinimize(ActionEvent event) {
		
	}

	public void showToUser(String response) {
		textConsoleOutput.setStyle("-fx-font-family: monospace");
		textConsoleOutput.insertText(textConsoleOutput.getLength(), response);

	}

	// Event Listener on Button[#btSend].onMouseClicked
	@FXML
	public void onMouseClicked(MouseEvent event) {

		processUIRequest();

	}
	
	

	private String onCommandReceived(String command) {

		String feedback;

		try {
			LogicController.getInstance();
			feedback = LogicController.onCommandProcess(command);
		} catch (InvalidCommandException e) {
			feedback = e.getMessage();
		}
		if (GoogleCalendarUtility.hasInternetConnection()) {
			GoogleCalendarManager.getInstance().performSync();
		}

		return feedback;
	}

	@FXML
	public void onEnter(ActionEvent event) {
		processUIRequest();

	}

	private void processUIRequest() {
		try {
			String response = onCommandReceived(textCommandInput.getText()) + "\n";
			showToUser(response);
		} catch (NullPointerException ex) {
			showToUser("Please try again with command details. \n");
		} finally {
			textCommandInput.clear();
		}
	}
	
	public void processManualRequest(String command){
		try {
			String response = onCommandReceived(command) + "\n";
			showToUser(response);
		} catch (NullPointerException ex) {
			showToUser("Please try again with command details. \n");
		} finally {
			textCommandInput.clear();
		}
	}
	
	public void clearConsole(){
		if(this.textConsoleOutput != null){
			this.textConsoleOutput.clear();
		}	 
	}



}
```
###### test\application\ParserTest.java
``` java
import static org.junit.Assert.assertEquals;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;

import org.junit.Test;

import application.controller.parser.ParserFacade;
import application.controller.parser.UKDateParser;
import application.exception.InvalidCommandException;
import application.model.Command;
import application.model.Parameter;
import application.model.Task;

public class ParserTest {
	


	@Test
	public void testParseCommand1() throws InvalidCommandException {

		Command cmd = ParserFacade.getInstance().parseCommand(
				"add buy milk for mom \\p high \\t personal \\sdate 15/1/2015 13:00pm \\edate 13/2/2015 12:00pm \\place clementi ntuc").get(0);
		ArrayList<Parameter> paras = new ArrayList<Parameter>();
		paras.add(new Parameter(Parameter.START_DATE_ARGUMENT_TYPE, "15/1/2015 13:00pm"));
		paras.add(new Parameter(Parameter.END_DATE_ARGUMENT_TYPE, "13/2/2015 12:00pm"));
		paras.add(new Parameter(Parameter.PLACE_ARGUMENT_TYPE, "clementi ntuc"));
		paras.add(new Parameter(Parameter.PRIORITY_ARGUMENT_TYPE, "high"));
		paras.add(new Parameter(Parameter.TYPE_ARGUMENT_TYPE, "personal"));
		Command cmdCmp = new Command(Command.ADD_COMMAND_TYPE, "buy milk for mom", paras);

		assertEquals(cmd, cmdCmp);  

	}

	@Test
	public void testParseCommand2() throws InvalidCommandException {

		Command cmd = ParserFacade.getInstance().parseCommand("list").get(0);
		ArrayList<Parameter> paras = new ArrayList<Parameter>();

		Command cmdCmp = new Command(Command.LIST_COMMAND_TYPE, "", paras);

		assertEquals(cmd, cmdCmp);

	}

	@Test
	public void testParseCommand3() throws InvalidCommandException { 

		Command cmd = ParserFacade.getInstance().parseCommand("edit lala world").get(0);
		ArrayList<Parameter> paras = new ArrayList<Parameter>();

		Command cmdCmp = new Command(Command.EDIT_COMMAND_TYPE, "lala world", paras);

		assertEquals(cmd, cmdCmp);

	}
	
	@Test
	public void testSmartParseCommand1() throws InvalidCommandException{
		
		Command cmd = ParserFacade.getInstance().parseCommand(
				"add buy milk for mom @ 13/2/2015 12:00pm \\p high \\t personal").get(0);
		ArrayList<Parameter> paras = new ArrayList<Parameter>();
		paras.add(new Parameter(Parameter.END_DATE_ARGUMENT_TYPE, "13/2/2015 12:00pm"));
		paras.add(new Parameter(Parameter.PRIORITY_ARGUMENT_TYPE, "high"));
		paras.add(new Parameter(Parameter.TYPE_ARGUMENT_TYPE, "personal"));
		Command cmdCmp = new Command(Command.ADD_COMMAND_TYPE, "buy milk for mom", paras);

		assertEquals(cmd, cmdCmp);    
		
	}

	//Boundary/Equivalence Testing, testing it now with zero parameter.
	@Test
	public void testConvertAddCommandtoTask1() {

		Command cmd = new Command(Command.ADD_COMMAND_TYPE, "test 123", new ArrayList<Parameter>());

		Task taskCmp = new Task("test 123");

		Task tmpTask; 
		tmpTask = ParserFacade.getInstance().convertAddCommandtoTask(cmd);

		assertEquals(tmpTask, taskCmp);

	}
	
	//Boundary/Equivalence Testing, Testing it with one parameter.
	@Test
	public void testConvertAddCommandtoTask2() throws ParseException {

		DateFormat df1 = new SimpleDateFormat(ParserFacade.DATE_FORMAT_TYPE_100);
		ArrayList<Parameter> paras = new ArrayList<Parameter>();
		paras.add(new Parameter(Parameter.START_DATE_ARGUMENT_TYPE, "13/12/2015 9:00am"));
		//paras.add(new Parameter(Parameter.END_DATE_ARGUMENT_TYPE, "14/12/2015 13:00pm"));
		//paras.add(new Parameter(Parameter.PLACE_ARGUMENT_TYPE, "bpp"));
		//paras.add(new Parameter(Parameter.PRIORITY_ARGUMENT_TYPE, "high"));
		//paras.add(new Parameter(Parameter.TYPE_ARGUMENT_TYPE, "meeting"));

		Command cmd = new Command(Command.ADD_COMMAND_TYPE, "test 123", paras);

		Task taskCmp = new Task("test 123");
		//taskCmp.setEnd_date(df1.parse("14/12/2015 13:00pm"));
		taskCmp.setStart_date(df1.parse("13/12/2015 9:00am"));
		//taskCmp.setPlace_argument("bpp");
		//taskCmp.setPriority_argument("high");
		//taskCmp.setType_argument("meeting");
		Task tmpTask;
		tmpTask = ParserFacade.getInstance().convertAddCommandtoTask(cmd);
		assertEquals(tmpTask, taskCmp);

	}

	
	//Equivalence testing involved from testParseDate1() to testParseDate105()
	//For e.g : parsing 1/2 2am is enough, parsing 3/2 3am will most likely to pass. 
	@Test
	public void testParseDate1() throws ParseException {
		Date date = ParserFacade.getInstance().parseDate("1/2 2am");

		Calendar cal = Calendar.getInstance();
		cal.set(Calendar.DATE, 1);
		cal.set(Calendar.MONTH, 1);
		cal.set(Calendar.HOUR_OF_DAY, 2);
		cal.set(Calendar.MINUTE, 0);
		cal.set(Calendar.SECOND, 0);
		cal.set(Calendar.MILLISECOND, 0);
		assertEquals(cal.getTime(), date);

	}



	
	

	@Test
	public void testParseDate5() throws ParseException {
		Date date = ParserFacade.getInstance().parseDate("5/6");

		Calendar cal = Calendar.getInstance();
		cal.set(Calendar.DATE, 5);
		cal.set(Calendar.MONTH, 5);
		cal.set(Calendar.HOUR_OF_DAY, 0);
		cal.set(Calendar.MINUTE, 0);
		cal.set(Calendar.SECOND, 0);
		cal.set(Calendar.MILLISECOND, 0);
		assertEquals(cal.getTime(), date);

	}

	@Test
	public void testParseDate6() throws ParseException {
		Date date = ParserFacade.getInstance().parseDate("25/12 11:30pm");

		Calendar cal = Calendar.getInstance();
		cal.set(Calendar.DATE, 25);
		cal.set(Calendar.MONTH, 11); 
		cal.set(Calendar.HOUR_OF_DAY, 23);
		cal.set(Calendar.MINUTE, 30);
		cal.set(Calendar.SECOND, 0);
		cal.set(Calendar.MILLISECOND, 0);
		assertEquals(cal.getTime(), date);

	}

	@Test
	public void testParseDate7() throws ParseException {
		Date date = ParserFacade.getInstance().parseDate("3/8 15:30");

		Calendar cal = Calendar.getInstance();
		cal.set(Calendar.DATE, 3);
		cal.set(Calendar.MONTH, 7);
		cal.set(Calendar.HOUR_OF_DAY, 15);
		cal.set(Calendar.MINUTE, 30);
		cal.set(Calendar.SECOND, 0);
		cal.set(Calendar.MILLISECOND, 0);
		assertEquals(cal.getTime(), date);

	}



	
	@Test
	public void testParseDate10() throws ParseException {
		Date date = ParserFacade.getInstance().parseDate("next tuesday 3:45pm");

		Calendar cal = Calendar.getInstance();
		cal.set(Calendar.DAY_OF_WEEK, Calendar.TUESDAY);

		cal.set(Calendar.HOUR_OF_DAY, 15);
		cal.set(Calendar.MINUTE, 45);
		cal.set(Calendar.SECOND, 0);
		cal.set(Calendar.MILLISECOND, 0);
		assertEquals(new Date(cal.getTime().getTime() + UKDateParser.ONE_WEEK_IN_MS), date);

	}

	@Test
	public void testParseDate100() throws ParseException {
		Date date = ParserFacade.getInstance().parseDate("11/11/2016 15:30");

		Calendar cal = Calendar.getInstance();
		cal.set(Calendar.DATE, 11);
		cal.set(Calendar.MONTH, 10);
		cal.set(Calendar.YEAR, 2016);
		cal.set(Calendar.HOUR_OF_DAY, 15);
		cal.set(Calendar.MINUTE, 30);
		cal.set(Calendar.SECOND, 0);
		cal.set(Calendar.MILLISECOND, 0);
		assertEquals(cal.getTime(), date);

	}

	@Test
	public void testParseDate100_1() throws ParseException {
		Date date = ParserFacade.getInstance().parseDate("11/11/16 15:30");

		Calendar cal = Calendar.getInstance();
		cal.set(Calendar.DATE, 11);
		cal.set(Calendar.MONTH, 10);
		cal.set(Calendar.YEAR, 2016);
		cal.set(Calendar.HOUR_OF_DAY, 15);
		cal.set(Calendar.MINUTE, 30);
		cal.set(Calendar.SECOND, 0);
		cal.set(Calendar.MILLISECOND, 0);
		assertEquals(cal.getTime(), date);

	}

	@Test
	public void testParseDate101() throws ParseException {
		Date date = ParserFacade.getInstance().parseDate("11/11/2016 3:30am");

		Calendar cal = Calendar.getInstance();
		cal.set(Calendar.DATE, 11);
		cal.set(Calendar.MONTH, 10);
		cal.set(Calendar.YEAR, 2016);
		cal.set(Calendar.HOUR_OF_DAY, 3);
		cal.set(Calendar.MINUTE, 30);
		cal.set(Calendar.SECOND, 0);
		cal.set(Calendar.MILLISECOND, 0);
		assertEquals(cal.getTime(), date);

	}

	


	@Test
	public void testParseDate104() throws ParseException {
		Date date = ParserFacade.getInstance().parseDate("11/11/16 3am");

		Calendar cal = Calendar.getInstance();
		cal.set(Calendar.DATE, 11);
		cal.set(Calendar.MONTH, 10);
		cal.set(Calendar.YEAR, 2016);
		cal.set(Calendar.HOUR_OF_DAY, 3);
		cal.set(Calendar.MINUTE, 0);
		cal.set(Calendar.SECOND, 0);
		cal.set(Calendar.MILLISECOND, 0);
		assertEquals(cal.getTime(), date);

	}


}
```
